# -*- coding: utf-8 -*-
"""Predictive_Analysis_Module.ipynb

Automatically generated by Colaboratory.

## Predictive Analysis Module
This module creates looks at the top features from the human trauma list and looks into determining a logistic prediction the ALZ dataset
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.metrics import f1_score
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score

ALZ_plasma_p = pd.read_csv("application/ALZ_plasma_processed.csv", index_col=0).transpose()
ALZ_csf_p = pd.read_csv("application/ALZ_csf_processed.csv", index_col=0).transpose()
trauma_human_p = pd.read_csv("application/trauma_human_processed.csv", index_col=0).transpose()

sort_stress_top_all_plasma_cor = pd.read_csv("application/sort_stress_top_all_plasma_cor.csv", index_col=0)
sort_stress_top_top_plasma_cor =  pd.read_csv("application/sort_stress_top_top_plasma_cor.csv", index_col=0)
sort_stress_top_all_csf_cor =  pd.read_csv("application/sort_stress_top_all_csf_cor.csv", index_col=0)
sort_stress_top_top_csf_cor =  pd.read_csv("application/sort_stress_top_top_csf_cor.csv", index_col=0)

def get_test_train(dataframe):
  """
  Split data into test train set
  """
  train,test = train_test_split(dataframe, test_size=0.4)
  y_train_headers = train.index
  Y_train_num = []
  for i in y_train_headers:
    if i != None and "AD" in i:
      Y_train_num.append(1)
    else:
      Y_train_num.append(0)

  y_test_headers = test.index
  Y_test_num = []
  for i in y_test_headers:
    if i != None and "AD" in i:
      Y_test_num.append(1)
    else:
      Y_test_num.append(0)
  return train, test, Y_train_num, Y_test_num

def get_preds(X_train, X_test, Y_train, Y_test, metab):
  """
  This function will create the logistic regression predictive model and
  get the metrics. It will also create a confusion matrix
  """
  train_set = np.array(X_train[metab]).reshape(-1,1)
  test_set = np.array(X_test[metab]).reshape(-1,1)
  LogModel = LogisticRegression().fit(train_set, Y_train)
  y_pred = LogModel.predict(test_set)

  f1_ex = f1_score(Y_test, y_pred)
  accuracy = accuracy_score(Y_test, y_pred)
  prec_ex = precision_score(Y_test, y_pred)
  recall_ex = recall_score(Y_test, y_pred)

  cm = confusion_matrix(Y_test, y_pred)
  matrix_plot = ConfusionMatrixDisplay(confusion_matrix=cm)
  return f1_ex, accuracy, prec_ex, recall_ex, matrix_plot

plasma_trainX, plasma_testX, plasma_trainY, plasma_testY = get_test_train(ALZ_plasma_p)
csf_trainX, csf_testX, csf_trainY, csf_testY = get_test_train(ALZ_csf_p)

stress_plasma1 = pd.DataFrame()
matrix_list = []
for metabolite in range(len(sort_stress_top_all_plasma_cor)):
  f1, acc, prec, recall, matrix = get_preds(plasma_trainX, plasma_testX, plasma_trainY, plasma_testY, sort_stress_top_all_plasma_cor.index[metabolite])
  metric_list = [f1, acc, prec, recall]
  stress_plasma1[sort_stress_top_all_plasma_cor.index[metabolite]] = metric_list
  matrix_list.append(matrix)

stress_plasma1.index = ['f1', 'acc', 'prec', 'recall']
stress_plasma1 = stress_plasma1.transpose().sort_values(by=['acc'])

counter=1
for i in matrix_list:
  test = "application/Matrix_Plasma_ALL"+ str(counter) +".png"
  i.plot()
  plt.savefig(test)
  counter += 1
  if counter == 4:
    break

stress_plasma2 = pd.DataFrame()
matrix_list = []
for metabolite in range(len(sort_stress_top_top_plasma_cor)):
  f1, acc, prec, recall, matrix = get_preds(plasma_trainX, plasma_testX, plasma_trainY, plasma_testY, sort_stress_top_top_plasma_cor.index[metabolite])
  metric_list = [f1, acc, prec, recall]
  stress_plasma2[sort_stress_top_top_plasma_cor.index[metabolite]] = metric_list
  matrix_list.append(matrix)

stress_plasma2.index = ['f1', 'acc', 'prec', 'recall']
stress_plasma2 = stress_plasma2.transpose().sort_values(by=['acc'])
counter=1
for i in matrix_list:
  test = "application/Matrix_Plasma_TOP"+ str(counter) +".png"
  i.plot()
  plt.savefig(test)
  counter += 1
  if counter == 4:
    break

stress_csf1 = pd.DataFrame()
matrix_list = []
for metabolite in range(len(sort_stress_top_all_csf_cor)):
  f1, acc, prec, recall, matrix = get_preds(csf_trainX, csf_testX, csf_trainY, csf_testY, sort_stress_top_all_csf_cor.index[metabolite])
  metric_list = [f1, acc, prec, recall]
  stress_csf1[sort_stress_top_all_csf_cor.index[metabolite]] = metric_list
  matrix_list.append(matrix)

stress_csf1.index = ['f1', 'acc', 'prec', 'recall']
stress_csf1 = stress_csf1.transpose().sort_values(by=['acc'])

counter=1
for i in matrix_list:
  test = "application/Matrix_CSF_ALL"+ str(counter) +".png"
  i.plot()
  plt.savefig(test)
  counter += 1
  if counter == 4:
    break

stress_csf2 = pd.DataFrame()
matrix_list = []
for metabolite in range(len(sort_stress_top_top_csf_cor)):
  f1, acc, prec, recall, matrix = get_preds(csf_trainX, csf_testX, csf_trainY, csf_testY, sort_stress_top_top_csf_cor.index[metabolite])
  metric_list = [f1, acc, prec, recall]
  stress_csf2[sort_stress_top_top_csf_cor.index[metabolite]] = metric_list
  matrix_list.append(matrix)

stress_csf2.index = ['f1', 'acc', 'prec', 'recall']
stress_csf2 = stress_csf2.transpose().sort_values(by=['acc'])

stress_plasma1.to_csv("application/stress_top_plasma_all_pred.csv")
stress_plasma2.to_csv("application/stress_top_plasma_top_pred.csv")
stress_csf1.to_csv("application/stress_top_csf_all_pred.csv")
stress_csf2.to_csv("application/stress_top_csf_top_pred.csv")


"""## References
Harris, C. R., Millman, K. J., van der Walt, S. J., Gommers, R., Virtanen, P., Cournapeau, D., Wieser, E., Taylor, J., Berg, S., Smith, N. J., Kern, R., Picus, M., Hoyer, S., van Kerkwijk, M. H., Brett, M., Haldane, A., del Río, J. F., Wiebe, M., Peterson, P., … Oliphant, T. E. (2020). Array programming with NumPy. Nature, 585(7825), 357–362. https://doi.org/10.1038/s41586-020-2649-2

Hunter, J. D. (2007). Matplotlib: A 2D Graphics Environment. Computing in Science & Engineering, 9(3), 90–95. https://doi.org/10.1109/MCSE.2007.55

Joshi, S. (2020, May 1). Save Plots as an Image File Without Displaying in Matplotlib. Delft Stack. https://www.delftstack.com/howto/matplotlib/how-to-save-plots-as-an-image-file-without-displaying-in-matplotlib/

Larose, C., & Larose, D. (2019). Data Science Using Python and R. John Wiley & Sons, Inc.

Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., Blondel, M., Prettenhofer, P., Weiss, R., Dubourg, V., Vanderplas, J., Passos, A., Cournapeau, D., Brucher, M., Perrot, M., & Duchesnay, E. (2011). 

Scikit-learn: Machine Learning in Python. Journal of Machine Learning Research, 12, 2825–2830.

Reback, J., Jbrockmendel, McKinney, W., Van Den Bossche, J., Augspurger, T., Roeschke, M., Hawkins, S., Cloud, P., Gfyoung, Sinhrks, Hoefler, P., Klein, A., Terji Petersen, Tratner, J., She, C., Ayd, W., Naveh, S., JHM Darbyshire, Garcia, M., … Battiston, P. (2022). pandas-dev/pandas: Pandas 1.4.2 (v1.4.2). Zenodo. https://doi.org/10.5281/ZENODO.3509134

Wu, S. (2021, June 5). What are the best metrics to evaluate your regression model? Medium. https://towardsdatascience.com/what-are-the-best-metrics-to-evaluate-your-regression-model-418ca481755b


"""

