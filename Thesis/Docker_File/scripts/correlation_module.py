# -*- coding: utf-8 -*-
"""Correlation_Module.ipynb

Automatically generated by Colaboratory.



## Correlation Module
This module will import the processed csv files and the lists of selected features. It will determine if there is any similarities in the files. It then runs a correlation analysis of the similar features between stress and ALZ. It calculates pvalues, standard error, RMSE, and spearman correlation coefficient.
It outputs into files.
"""

import numpy as np
import pandas as pd
import statsmodels.api as sm 
from scipy import stats
from sklearn.model_selection import train_test_split
from statsmodels.tools.eval_measures import rmse

from google.colab import drive
drive.mount('/content/drive')

# read in files
ALZ_plasma_feat = pd.read_csv("ALZ_plasma_selected_features.csv", index_col=0)
ALZ_csf_feat = pd.read_csv("ALZ_csf_selected_features.csv", index_col=0)
trauma_human_feat = pd.read_csv("trauma_human_selected_features.csv", index_col=0)

ALZ_plasma_p = pd.read_csv("ALZ_plasma_processed.csv", index_col=0).transpose()
ALZ_csf_p = pd.read_csv("ALZ_csf_processed.csv", index_col=0).transpose()
trauma_human_p = pd.read_csv("trauma_human_processed.csv", index_col=0).transpose()

ALZ_plasma_feat.columns

trauma_human_feat.columns

ALZ_csf_feat.columns

stress_topVS_all_plasma = []
for val in trauma_human_feat.columns:
  for col in ALZ_plasma_p.columns:
    if val in col:
      stress_topVS_all_plasma.append(col)

stress_topVS_all_csf = []
for val in trauma_human_feat.columns:
  for col in ALZ_csf_p.columns:
    if val in col:
      stress_topVS_all_csf.append(col)

stress_topVS_plasma_top = []
for val in trauma_human_feat.columns:
  for col in ALZ_plasma_feat.columns:
    if val in col:
      stress_topVS_plasma_top.append(col)

stress_topVS_csf_top = []
for val in trauma_human_feat.columns:
  for col in ALZ_csf_feat.columns:
    if val in col:
      stress_topVS_csf_top.append(col)

for val in ALZ_csf_feat.columns:
  for col in ALZ_plasma_feat.columns:
    if val in col:
      print(col)

def calculate_corr(x_array, y_array, metabolite):
  """
  calculates the spearman correlation for the given metabolite. The x_array is a
  dataframe that contains all metabolites. The y_array is the binary variables.
  """
  cor_matrix_initial = pd.DataFrame({metabolite: x_array[metabolite], 'ALZ': y_array})
  corr_matrix = cor_matrix_initial.corr(method='spearman')
  correlation_val = corr_matrix[metabolite][1]
  return correlation_val

def calculate_log_values(X_train, X_test, Y_train, Y_test, Metabolite):
  """
  This function will take the test and train datasets with the metabolites
  to help run the correlation analysis. The output variables include pvalue
  standard error, RMSE value.
  """
  X_train1 = X_train[Metabolite]
  X_train1 = sm.add_constant(X_train1)
  logreg1 = sm.Logit(Y_train, X_train1).fit()
  pvalue_train = logreg1.pvalues[1]
  stand_error_train = logreg1.bse[1] #standard error

  X_test1 = X_test[Metabolite]
  X_test1 = sm.add_constant(X_test1)
  logreq1_test = sm.Logit(Y_test, X_test1).fit()
  ypred = logreg1.predict(X_test1)
  rmse2 = rmse(Y_test, ypred)

  return pvalue_train, stand_error_train, rmse2

def correlation_main(dataframe, metabList):
  """
  This function will take the two above functions and complie it into a dataframe.
  The first part creates the test and train dataset from the processed csv file.
  It then will calculate the logistic values for the similar metabolites.
  The output is a dataframe.
  """
  # split data
  train,test = train_test_split(dataframe, test_size=0.4)
  y_train_headers = train.index
  Y_train_num = []
  for i in y_train_headers:
    if i != None and "AD" in i:
      Y_train_num.append(1)
    else:
      Y_train_num.append(0)

  y_test_headers = test.index
  Y_test_num = []
  for i in y_test_headers:
    if i != None and "AD" in i:
      Y_test_num.append(1)
    else:
      Y_test_num.append(0)

  #calculate logistic values
  output_frame = pd.DataFrame()
  for metab in metabList:
    pvalues, standard_error, RMSE_val = calculate_log_values(train, test, Y_train_num, Y_test_num, metab)
    corr_value = calculate_corr(train, Y_train_num, metab)
    logistic_list = [pvalues, standard_error, RMSE_val, corr_value]
    output_frame[metab] = logistic_list

  output_frame.index = ['pvalues', 'standard error', 'RMSE', "Spearman Corr"]

  return output_frame

stress_top_all_plasma_cor = correlation_main(ALZ_plasma_p, stress_topVS_all_plasma)
stress_top_top_plasma_cor = correlation_main(ALZ_plasma_p, stress_topVS_plasma_top)
stress_top_all_csf_cor = correlation_main(ALZ_csf_p, stress_topVS_all_csf)
stress_top_top_csf_cor = correlation_main(ALZ_csf_p, stress_topVS_csf_top)

sort_stress_top_all_plasma_cor = stress_top_all_plasma_cor.transpose().sort_values(by=['pvalues'])
sort_stress_top_top_plasma_cor = stress_top_top_plasma_cor.transpose().sort_values(by=['pvalues'])
sort_stress_top_all_csf_cor = stress_top_all_csf_cor.transpose().sort_values(by=['pvalues'])
sort_stress_top_top_csf_cor = stress_top_top_csf_cor.transpose().sort_values(by=['pvalues'])

sort_stress_top_top_csf_cor

sort_stress_top_all_csf_cor

sort_stress_top_top_plasma_cor

sort_stress_top_all_plasma_cor

#save values
sort_stress_top_all_plasma_cor.to_csv("sort_stress_top_all_plasma_cor.csv")
sort_stress_top_top_plasma_cor.to_csv("sort_stress_top_top_plasma_cor.csv")
sort_stress_top_all_csf_cor.to_csv("sort_stress_top_all_csf_cor.csv")
sort_stress_top_top_csf_cor.to_csv("sort_stress_top_top_csf_cor.csv")
