# -*- coding: utf-8 -*-
"""Project5_DSC550_Quinton.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mHOO9xmSsiktQj7MOetMHBLgGWQjOTNp
"""

#Programmer = Sophia Quinton
#Class = DSC 550
#Date = 2-9-22
#Assignment = Project 5

#libraries
# (Harris et. al., 2020) (McKinney et. al., 2010) (PYNative, 2021)
import pandas as pd
import numpy as np
import random

#Generate random data
true_banana = [-1,1,1]
true_pineapple = [-1,-1,-1]

options = [1,-1]

k=100
i=1
samples = []
# (PYNative, 2021)
while i < k:
  sample = [random.choice(options), random.choice(options), random.choice(options)]
  samples.append(sample)
  i += 1

#create true results
fruit_type = []
for i in range(len(samples)):
  if samples[i][0] == -1 and samples[i][1] == 1 and samples[i][2] == 1:
    fruit_type.append("banana")
  elif samples[i][0] == -1 and samples[i][1] == -1 and samples[i][2] == -1:
    fruit_type.append("pineapple")
  elif samples[i][1] == -1:
    fruit_type.append("pineapple")
  elif samples[i][1] == 1:
    fruit_type.append("banana")
  else:
    fruit_type.append("other")

fruit_type

# train and build
w = np.array([[-0.5, 0.5, 0.5], [-0.5, -0.5, -0.5]])
w

w[1]

#bias
b = 3/2
b

def Layer_One(input, bias, weight):
  y_in1 = bias + sum(input * weight[0])
  y_in2 = bias + sum(input * weight[1])
  return y_in1, y_in2

# second layer MAXNET
def MaxNetfunction(x):
  if x > 0 or x == 0:
    result = x
  else:
    result = 0
  return result

def end_Max_check(in1, in2):
  if in1 == 0 and in2 != 0:
    result = 2
  elif in2 == 0 and in1 != 0:
    result = 1
  else:
    result = 3
  return result

def Layer_Two(input1, input2, epsilon, itt):
  end = 3
  interator = 0
  if input1 == input2:
    input1 = input1 + 1
  while end == 3:
    print("inputs: ", input1, input2)
    a1_1 = MaxNetfunction(input1 - (epsilon * input2))
    a2_1 = MaxNetfunction(input2 - (epsilon * input1))
    print("result: ", a1_1, a2_1)
    input1 = a1_1
    input2 = a2_1
    end = end_Max_check(a1_1, a2_1)
    interator += 1
    if interator > itt:
      end = 4
    print(end)
  return end

my_result = Layer_Two(2, 2, 0.4, 3)

def calculate_fruit(z):
  if z == 1:
    result = "banana"
  elif z == 2:
    result = "pineapple"
  else:
    result = "issue"
  return result

## test with a few features
# test with banana result
y_in1, y_in2 = Layer_One([-1,1,1], b, w) 
my_result = Layer_Two(y_in1, y_in2, 0.4, 5)
first_test = calculate_fruit(my_result)
print([-1,1,1])
print("Test with banana result: ", first_test)

# test with pineapple result
y_in1, y_in2 = Layer_One([-1,-1,-1], b, w) 
my_result = Layer_Two(y_in1, y_in2, 0.1, 5)
second_test = calculate_fruit(my_result)
print([-1,-1,-1])
print("Test with pineapple result: ", second_test)

# test with random 1
y_in1, y_in2 = Layer_One([-1,1,-1], b, w) 
my_result = Layer_Two(y_in1, y_in2, 0.25, 5)
test = calculate_fruit(my_result)
print([-1,1,-1])
print("Test with random result: ", test)

# test with random 2
y_in1, y_in2 = Layer_One([1,1,1], b, w) 
my_result = Layer_Two(y_in1, y_in2, 0.4, 5)
test = calculate_fruit(my_result)
print([1,1,-1])
print("Test with random result: ", test)

### automation
test_class = []
for i in range(len(samples)):
  y_in1, y_in2 = Layer_One(samples[i], b, w) 
  my_result = Layer_Two(y_in1, y_in2, 0.4, 5)
  test = calculate_fruit(my_result)
  test_class.append(test)

accuracy = []
for i in range(len(test_class)):
  if test_class[i] == fruit_type[i]:
    accuracy.append(1)
  else:
    accuracy.append(0)

sum(accuracy)/len(test_class)

